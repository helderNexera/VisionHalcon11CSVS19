//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 11.0
//


using HalconDotNet;

public partial class HDevelopExport
{
  // Chapter: Graphics / Text
  // Short Description: This procedure writes a text message. 
  public void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
  {


      // Local control variables 

      HTuple hv_M = null, hv_N = null, hv_Red = null;
      HTuple hv_Green = null, hv_Blue = null, hv_RowI1Part = null;
      HTuple hv_ColumnI1Part = null, hv_RowI2Part = null, hv_ColumnI2Part = null;
      HTuple hv_RowIWin = null, hv_ColumnIWin = null, hv_WidthWin = null;
      HTuple hv_HeightWin = null, hv_I = null, hv_RowI = new HTuple();
      HTuple hv_ColumnI = new HTuple(), hv_StringI = new HTuple();
      HTuple hv_MaxAscent = new HTuple(), hv_MaxDescent = new HTuple();
      HTuple hv_MaxWidth = new HTuple(), hv_MaxHeight = new HTuple();
      HTuple hv_R1 = new HTuple(), hv_C1 = new HTuple(), hv_FactorRowI = new HTuple();
      HTuple hv_FactorColumnI = new HTuple(), hv_UseShadow = new HTuple();
      HTuple hv_ShadowColor = new HTuple(), hv_Exception = new HTuple();
      HTuple hv_Width = new HTuple(), hv_Index = new HTuple();
      HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
      HTuple hv_W = new HTuple(), hv_H = new HTuple(), hv_FrameHeight = new HTuple();
      HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
      HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
      HTuple hv_CurrentColor = new HTuple();

      HTuple   hv_Box_COPY_INP_TMP = hv_Box.Clone();
      HTuple   hv_Color_COPY_INP_TMP = hv_Color.Clone();
      HTuple   hv_Column_COPY_INP_TMP = hv_Column.Clone();
      HTuple   hv_Row_COPY_INP_TMP = hv_Row.Clone();
      HTuple   hv_String_COPY_INP_TMP = hv_String.Clone();

      // Initialize local and output iconic variables 

    //This procedure displays text in a graphics window.
    //
    //Input parameters:
    //WindowHandle: The WindowHandle of the graphics window, where
    //   the message should be displayed
    //String: A tuple of strings containing the text message to be displayed
    //CoordSystem: If set to 'window', the text position is given
    //   with respect to the window coordinate system.
    //   If set to 'image', image coordinates are used.
    //   (This may be useful in zoomed images.)
    //Row: The row coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //   A tuple of values is allowed to display text at different
    //   positions.
    //Column: The column coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //   A tuple of values is allowed to display text at different
    //   positions.
    //Color: defines the color of the text as string.
    //   If set to [], '' or 'auto' the currently set color is used.
    //   If a tuple of strings is passed, the colors are used cyclically...
    //   - if |Row| == |Column| == 1: for each new textline
    //   = else for each text position.
    //Box: If Box[0] is set to 'true', the text is written within a white box.
    //     If set to' false', no box is displayed.
    //     If set to a color string (e.g. 'black', '#FF00CC', etc.),
    //       the text is written in a box of that color.
    //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
    //       'true' -> display a shadow in a default color
    //       'false' -> display no shadow
    //       otherwise -> use given string as color string for the shadow color
    //
    //It is possible to display multiple text strings in a single call.
    //In this case, some restrictions apply:
    //- Multiple text positions can be defined by specifying a tuple
    //  with multiple Row and/or Column coordinates, i.e.:
    //  - |Row| == n, |Column| == n
    //  - |Row| == n, |Column| == 1
    //  - |Row| == 1, |Column| == n
    //- If |Row| == |Column| == 1,
    //  each element of String is display in a new textline.
    //- If multiple positions or specified, the number of Strings
    //  must match the number of positions, i.e.:
    //  - Either |String| == n (each string is displayed at the
    //                          corresponding position),
    //  - or     |String| == 1 (The string is displayed n times).
    //
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_Color_COPY_INP_TMP = "";
    }
    if ((int)(new HTuple(hv_Box_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_Box_COPY_INP_TMP = "false";
    }
    //
    //
    //Check conditions
    //
    hv_M = (new HTuple(hv_Row_COPY_INP_TMP.TupleLength()))*(new HTuple(hv_Column_COPY_INP_TMP.TupleLength()
        ));
    hv_N = new HTuple(hv_Row_COPY_INP_TMP.TupleLength());
    if ((int)((new HTuple(hv_M.TupleEqual(0))).TupleOr(new HTuple(hv_String_COPY_INP_TMP.TupleEqual(
        new HTuple())))) != 0)
    {

      return;
    }
    if ((int)(new HTuple(hv_M.TupleNotEqual(1))) != 0)
    {
      //Multiple positions
      //
      //Expand single parameters
      if ((int)(new HTuple((new HTuple(hv_Row_COPY_INP_TMP.TupleLength())).TupleEqual(
          1))) != 0)
      {
        hv_N = new HTuple(hv_Column_COPY_INP_TMP.TupleLength());
        HOperatorSet.TupleGenConst(hv_N, hv_Row_COPY_INP_TMP, out hv_Row_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_Column_COPY_INP_TMP.TupleLength()
          )).TupleEqual(1))) != 0)
      {
        HOperatorSet.TupleGenConst(hv_N, hv_Column_COPY_INP_TMP, out hv_Column_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_Column_COPY_INP_TMP.TupleLength()
          )).TupleNotEqual(new HTuple(hv_Row_COPY_INP_TMP.TupleLength())))) != 0)
      {
        throw new HalconException("Number of elements in Row and Column does not match.");
      }
      if ((int)(new HTuple((new HTuple(hv_String_COPY_INP_TMP.TupleLength())).TupleEqual(
          1))) != 0)
      {
        HOperatorSet.TupleGenConst(hv_N, hv_String_COPY_INP_TMP, out hv_String_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          )).TupleNotEqual(hv_N))) != 0)
      {
        throw new HalconException("Number of elements in Strings does not match number of positions.");
      }
      //
    }
    //
    //Prepare window
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    HOperatorSet.GetPart(hv_WindowHandle, out hv_RowI1Part, out hv_ColumnI1Part, 
        out hv_RowI2Part, out hv_ColumnI2Part);
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowIWin, out hv_ColumnIWin, 
        out hv_WidthWin, out hv_HeightWin);
    HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
    //
    //Loop over all positions
    HTuple end_val89 = hv_N-1;
    HTuple step_val89 = 1;
    for (hv_I=0; hv_I.Continue(end_val89, step_val89); hv_I = hv_I.TupleAdd(step_val89))
    {
      hv_RowI = hv_Row_COPY_INP_TMP.TupleSelect(hv_I);
      hv_ColumnI = hv_Column_COPY_INP_TMP.TupleSelect(hv_I);
      //Allow multiple strings for a single position.
      if ((int)(new HTuple(hv_N.TupleEqual(1))) != 0)
      {
        hv_StringI = hv_String_COPY_INP_TMP.Clone();
      }
      else
      {
        //In case of multiple positions, only single strings
        //are allowed per position.
        //For line breaks, use \n in this case.
        hv_StringI = hv_String_COPY_INP_TMP.TupleSelect(hv_I);
      }
      //Default settings
      //-1 is mapped to 12.
      if ((int)(new HTuple(hv_RowI.TupleEqual(-1))) != 0)
      {
        hv_RowI = 12;
      }
      if ((int)(new HTuple(hv_ColumnI.TupleEqual(-1))) != 0)
      {
        hv_ColumnI = 12;
      }
      //
      //Split string into one string per line.
      hv_StringI = (((""+hv_StringI)+"")).TupleSplit("\n");
      //
      //Estimate extentions of text depending on font size.
      HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent, 
          out hv_MaxWidth, out hv_MaxHeight);
      if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
      {
        hv_R1 = hv_RowI.Clone();
        hv_C1 = hv_ColumnI.Clone();
      }
      else
      {
        //Transform image to window coordinates.
        hv_FactorRowI = (1.0*hv_HeightWin)/((hv_RowI2Part-hv_RowI1Part)+1);
        hv_FactorColumnI = (1.0*hv_WidthWin)/((hv_ColumnI2Part-hv_ColumnI1Part)+1);
        hv_R1 = (((hv_RowI-hv_RowI1Part)+0.5)*hv_FactorRowI)-0.5;
        hv_C1 = (((hv_ColumnI-hv_ColumnI1Part)+0.5)*hv_FactorColumnI)-0.5;
      }
      //
      //Display text box depending on text size.
      hv_UseShadow = 1;
      hv_ShadowColor = "gray";
      if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleEqual("true"))) != 0)
      {
        if (hv_Box_COPY_INP_TMP == null)
          hv_Box_COPY_INP_TMP = new HTuple();
        hv_Box_COPY_INP_TMP[0] = "white";
      }
      if ((int)(new HTuple((new HTuple(hv_Box_COPY_INP_TMP.TupleLength())).TupleGreater(
          1))) != 0)
      {
        if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual("true"))) != 0)
        {
          //Use default ShadowColor set above
        }
        else if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual(
            "false"))) != 0)
        {
          hv_UseShadow = 0;
        }
        else
        {
          hv_ShadowColor = hv_Box_COPY_INP_TMP[1];
          //Valid color?
          try
          {
            HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(
                1));
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
            throw new HalconException(hv_Exception);
          }
        }
      }
      if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleNotEqual("false"))) != 0)
      {
        //Valid color?
        try
        {
          HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(
              0));
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
          throw new HalconException(hv_Exception);
        }
        //Calculate box extents
        hv_StringI = (" "+hv_StringI)+" ";
        hv_Width = new HTuple();
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_StringI.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_StringI.TupleSelect(hv_Index), 
              out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
          hv_Width = hv_Width.TupleConcat(hv_W);
        }
        hv_FrameHeight = hv_MaxHeight*(new HTuple(hv_StringI.TupleLength()));
        hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
        hv_R2 = hv_R1+hv_FrameHeight;
        hv_C2 = hv_C1+hv_FrameWidth;
        //Display rectangles
        HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
        HOperatorSet.SetDraw(hv_WindowHandle, "fill");
        //Set shadow color
        HOperatorSet.SetColor(hv_WindowHandle, hv_ShadowColor);
        if ((int)(hv_UseShadow) != 0)
        {
          HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1+1, hv_C1+1, hv_R2+1, 
              hv_C2+1);
        }
        //Set box color
        HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
        HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
        HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
      }
      //Write text.
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_StringI.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        //Set color
        if ((int)(new HTuple(hv_N.TupleEqual(1))) != 0)
        {
          //Wiht a single text position, each text line
          //may get a different color.
          hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
              )));
        }
        else
        {
          //With multiple text positions, each position
          //gets a single color for all text lines.
          hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_I%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
              )));
        }
        if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
            "auto")))) != 0)
        {
          //Valid color?
          try
          {
            HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            hv_Exception = ((("Wrong value of control parameter Color["+(hv_Index%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                ))))+"] == '")+hv_CurrentColor)+"' (must be a valid color string)";
            throw new HalconException(hv_Exception);
          }
        }
        else
        {
          HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
        }
        //Finally display text
        hv_RowI = hv_R1+(hv_MaxHeight*hv_Index);
        HOperatorSet.SetTposition(hv_WindowHandle, hv_RowI, hv_C1);
        HOperatorSet.WriteString(hv_WindowHandle, hv_StringI.TupleSelect(hv_Index));
      }
    }
    //Reset changed window settings
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    HOperatorSet.SetPart(hv_WindowHandle, hv_RowI1Part, hv_ColumnI1Part, hv_RowI2Part, 
        hv_ColumnI2Part);

    return;
  }

}
